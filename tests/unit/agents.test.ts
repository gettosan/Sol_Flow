/**
 * Unit Tests for Autonomous Agents
 */

import { describe, it, expect, beforeEach } from '@jest/globals';
import { agentCoordinator } from '../../src/agents/coordinator';
import { marketAnalysisAgent } from '../../src/agents/marketAnalysis';
import { smartRouterAgent } from '../../src/agents/smartRouter';
import { mevHunterAgent } from '../../src/agents/mevHunter';
import { SwapQuote } from '../../src/types';

describe('Autonomous Agents', () => {
  beforeEach(() => {
    // Reset agent state if needed
  });

  describe('Agent Coordinator', () => {
    it('should register agents correctly', () => {
      const agents = agentCoordinator.getAgents();
      
      expect(agents.length).toBeGreaterThanOrEqual(3);
      expect(agents).toContain('market_analysis_agent');
      expect(agents).toContain('smart_router_agent');
      expect(agents).toContain('mev_hunter_agent');
    });

    it('should check if agent is available', () => {
      expect(agentCoordinator.isAgentAvailable('market_analysis_agent')).toBe(true);
      expect(agentCoordinator.isAgentAvailable('unknown_agent')).toBe(false);
    });
  });

  describe('Market Analysis Agent', () => {
    it('should analyze market conditions', async () => {
      const request = {
        tokenPairs: [
          { inputMint: 'So11111111111111111111111111111111111111112', outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' },
        ],
        timeframe: '1h' as const,
      };

      const analysis = await marketAnalysisAgent.analyzeMarket(request);

      expect(analysis).toBeDefined();
      expect(analysis.analysis).toBeInstanceOf(Array);
      expect(analysis.analysis.length).toBeGreaterThan(0);
      expect(analysis.timestamp).toBeDefined();
    });

    it('should get liquidity scores', async () => {
      const pairs = [
        { inputMint: 'SOL_MINT', outputMint: 'USDC_MINT' },
        { inputMint: 'USDC_MINT', outputMint: 'USDT_MINT' },
      ];

      const scores = await marketAnalysisAgent.getLiquidityScores(pairs);

      expect(scores.size).toBe(2);
      
      // The pair names are generated by taking first 8 chars of each mint
      const pairNames = Array.from(scores.keys());
      expect(pairNames.length).toBeGreaterThan(0);
    });

    it('should recommend trading pairs', async () => {
      const recommendations = await marketAnalysisAgent.recommendPairs(3);

      expect(recommendations).toBeInstanceOf(Array);
      expect(recommendations.length).toBe(3);
      expect(recommendations[0]).toHaveProperty('pair');
      expect(recommendations[0]).toHaveProperty('score');
      expect(recommendations[0]).toHaveProperty('risk');
    });
  });

  describe('Smart Router Agent', () => {
    it('should optimize routes', async () => {
      const request = {
        inputMint: 'So11111111111111111111111111111111111111112',
        outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
        amount: '1000000000', // 1 SOL
        constraints: {
          maxSlippage: 100,
          maxRoutes: 3,
        },
      };

      const response = await smartRouterAgent.optimizeRoute(request);

      expect(response).toBeDefined();
      expect(response.optimizedRoutes).toBeInstanceOf(Array);
      expect(response.optimizedRoutes.length).toBeGreaterThan(0);
      expect(response.analysis).toBeDefined();
      expect(response.analysis.efficiency).toBeDefined();
    });

    it('should find best route', async () => {
      const route = await smartRouterAgent.findBestRoute(
        'SOL_MINT',
        'USDC_MINT',
        '1000000000'
      );

      if (route) {
        expect(route.inputAmount).toBeDefined();
        expect(route.outputAmount).toBeDefined();
        expect(route.routes).toBeInstanceOf(Array);
      }
    });
  });

  describe('MEV Hunter Agent', () => {
    const mockQuote: SwapQuote = {
      inputAmount: '1000000000',
      outputAmount: '100000000',
      priceImpact: 2.0,
      routes: [],
      estimatedGas: 3000,
      timestamp: Date.now(),
      quoteId: 'test-quote',
      mevProtected: false,
      expiresAt: Date.now() + 60000,
    };

    it('should detect MEV threats', async () => {
      const detection = await mevHunterAgent.detectMevThreats(mockQuote);

      expect(detection).toBeDefined();
      expect(detection.detected).toBeDefined();
      expect(detection.confidence).toBeGreaterThanOrEqual(0);
      expect(detection.confidence).toBeLessThanOrEqual(1);
      expect(detection.threats).toBeInstanceOf(Array);
    });

    it('should assess swap safety', async () => {
      const assessment = await mevHunterAgent.assessSwapSafety(mockQuote);

      expect(assessment).toBeDefined();
      expect(assessment).toHaveProperty('safe');
      expect(assessment).toHaveProperty('risks');
      expect(assessment).toHaveProperty('recommendations');
      expect(assessment.risks).toBeInstanceOf(Array);
      expect(assessment.recommendations).toBeInstanceOf(Array);
    });

    it('should detect high price impact', async () => {
      const highImpactQuote: SwapQuote = {
        ...mockQuote,
        priceImpact: 10.0,
      };

      const detection = await mevHunterAgent.detectMevThreats(highImpactQuote);

      expect(detection.detected).toBe(true);
      expect(detection.threats.length).toBeGreaterThan(0);
    });
  });
});

